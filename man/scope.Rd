% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scope.R
\name{scope}
\alias{scope}
\alias{localize}
\alias{globalize}
\alias{predicate_function}
\alias{predicate_message}
\alias{predicate_message<-}
\title{Generate input validation checks}
\usage{
localize(p)

globalize(lp)

predicate_function(x)

predicate_message(x)

predicate_message(x) <- value
}
\arguments{
\item{p}{Predicate function, or a definition, whose LHS is an error message
(string) and whose RHS is a predicate function.}

\item{lp}{Function of class \code{local_predicate}, i.e., a function created by
\code{localize()}.}

\item{x}{Object of class \code{local_predicate} or \code{global_predicate}.}

\item{value}{Error message (string).}
}
\description{
Given a predicate (function), \code{localize()} returns a function that
\emph{generates} input validation checks (of local scope) for the predicate.
\code{globalize()} takes such a check generator and returns the underlying error
message-predicate pair. When \code{globalize()} is unquoted in a call to
\code{\link[=firmly]{firmly()}} or \code{\link[=fasten]{fasten()}}, the corresponding predicate is applied as an input
validation check of global scope.
\cr\cr
The functions \code{predicate_function()} and \code{predicate_message()} extract the
associated predicate function and error message.
}
\details{
\code{globalize()} approximately inverts \code{localize()}, by returning the
underlying message-predicate pair as a named list, rather than as a
bare predicate function or definition (formula).
}
\examples{
\dontrun{

## Make a positivity checker
chk_positive <- localize("{{.}} is not positive" := {isTRUE(. > 0)})
f <- firmly(function(x, y) "Pass", chk_positive(x, x - y))

f(2, 1)
#> [1] "Pass"

f(1, 2)
#> Error: f(x = 1, y = 2)
#> x - y is not positive

## Make a parameterized length checker
chk_length <-
  localize(
    "{{.}} not of length {{l}}" := function(., l) length(.) == l
  )
## l gets the value 2 (so check that the length is 2)
g <- firmly(function(x, y) "Pass", chk_length(l = 2, y))

g(1, 1:2)
#> [1] "Pass"

g(1:2, 1)
#> Error: g(x = 1)
#> y not of length 2
}

}
