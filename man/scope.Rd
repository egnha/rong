% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scope.R
\name{scope}
\alias{scope}
\alias{localize}
\alias{localize_comparison}
\alias{globalize}
\alias{predicate_function}
\alias{predicate_message}
\alias{predicate_message<-}
\title{Generate input validation checks}
\usage{
localize(p, msg = "")

localize_comparison(p, msg = "")

globalize(chkr)

predicate_function(x)

predicate_message(x)

predicate_message(x) <- value
}
\arguments{
\item{p}{Predicate function of one argument, for \code{localize()}, of two or more
arguments for \code{localize_comparison()}.}

\item{msg, value}{Error message (string). An empty string (the default)
implies that error messages are to be automatically generated.}

\item{chkr}{Function of class \code{local_predicate}, i.e., a function created by
\code{localize()}.}

\item{x}{Object of class \code{local_predicate} or \code{global_predicate}.}
}
\description{
Given a predicate (function), \code{localize()} returns a function that
\emph{generates} input validation checks (of local scope) for the predicate.
\code{globalize()} takes such a check generator and returns the underlying
predicate (wrapped in \code{\link[=vld]{vld()}}); when \code{globalize()} is unquoted in a call to
\code{\link[=firmly]{firmly()}} or \code{\link[=fasten]{fasten()}}, the corresponding predicate is applied as an input
validation check of global scope.
\cr\cr
The function \code{predicate_function()}, resp. \code{predicate_message()}, extracts
the associated predicate function, resp. error message.
}
\details{
Conceptually, \code{localize()} and \code{globalize()} represent inverse
operations. However, they are \emph{not} mutually invertible as functions,
because they are not composable.
}
\examples{
\dontrun{
chk_pos_gbl <- "Not positive" ~ {. > 0}
chk_pos_lcl <- localize(chk_pos_gbl)
chk_pos_lcl(~x, "y not greater than x" ~ x - y)
# list("Not positive: x" ~ x, "y not greater than x" ~ x - y) ~ {. > 0}

pass <- function(x, y) "Pass"

# Impose local positivity checks
f <- firmly(pass, chk_pos_lcl(~x, "y not greater than x" ~ x - y))
f(2, 1)  # [1] "Pass"
f(2, 2)  # Error: "y not greater than x"
f(0, 1)  # Errors: "Not positive: x", "y not greater than x"

# Or just check positivity of x
g <- firmly(pass, chk_pos_lcl(~x))
g(1, 0)  # [1] "Pass"
g(0, 0)  # Error: "Not positive: x"

# In contrast, chk_pos_gbl checks positivity for all arguments
h <- firmly(pass, chk_pos_gbl)
h(2, 2)  # [1] "Pass"
h(1, 0)  # Error: "Not positive: `y`"
h(0, 0)  # Errors: "Not positive: `x`", "Not positive: `y`"

# Alternatively, globalize the localized checker
h2 <- firmly(pass, globalize(chk_pos_lcl))
all.equal(h, h2)  # [1] TRUE

# Use localize to make parameterized checkers
chk_lte <- function(n, ...) {
  err_msg <- paste("Not <=", as.character(n))
  localize(err_msg ~ {. <= n})(...)
}
fib <- function(n) {
  if (n <= 1) return(1)
  Recall(n - 1) + Recall(n - 2)
}
capped_fib <- firmly(fib, chk_lte(30, ~ ceiling(n)))
capped_fib(19)  # [1] 6765
capped_fib(31)  # Error: "Not <= 30: ceiling(n)"
}

}
