% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/checker.R
\name{checker}
\alias{checker}
\alias{chkr_predicate}
\alias{chkr_message}
\alias{chkr_message<-}
\title{Generate input validation checks}
\usage{
checker(..p, ...)

chkr_predicate(x)

chkr_message(x)

chkr_message(x, env = parent.frame()) <- value
}
\arguments{
\item{..p}{Predicate function, or a definition whose LHS is an error message
(string) and RHS is a predicate function (see \emph{Specifying predicate
functions}).}

\item{...}{Predicate-argument transformers as named functions (see
\emph{Transforming predicate arguments}).}

\item{x}{Function created by \code{checker()}.}

\item{env}{Environment that is in scope if and when the error-message string
is produced (and interpolated).}

\item{value}{Error message (string).}
}
\value{
Function that generates input validation checks.
}
\description{
Given a predicate function, \code{checker()} makes a function that \emph{generates}
input validation checks for use with \code{\link[=firmly]{firmly()}} or \code{\link[=fasten]{fasten()}}. The functions
\code{chkr_predicate()} and \code{chkr_message()} extract the associated predicate
function and error message.
}
\section{Specifying error messages}{
 TODO:
\itemize{
\item double \code{\{\{} vs single \code{\{}
\item \code{.expr} pronoun
\item \code{.value} pronoun
}
}

\section{Specifying predicate functions}{
 TODO: ways to specify function
literals
}

\section{Transforming predicate arguments}{
 TODO
}

\examples{
f <- function(x, y) "Pass"

## Make a positivity checker
chk_pos <- checker("{{.}} is not positive" := {isTRUE(. > 0)})
foo <- firmly(f, chk_pos(x, x - y))

foo(2, 1)
\dontrun{
foo(1, 2)}

## Make a parameterized length checker
msg <- "{{.}} not of length {{.value$l}} (actual length: {length(.)})"
chk_len <- checker(msg := function(., l) length(.) == l)

## Equivalently, use abbreviated notation for anonymous functions
chk_len <- checker(msg := .(., l ~ length(.) == l))

bar <- firmly(f, chk_len(l = 2, y))

bar(1, 1:2)
\dontrun{
bar(1:2, 1)}

## Apply a checker to all function arguments, by specifying none explicitly
baz <- firmly(f, chk_len(1))

baz(1, 2)
\dontrun{
baz(1, 2:3)}

## Rewrite the error message
chkr_message(chk_len) <- "Length of {{.}} is {length(.)} not {{.expr$l}}"

len <- 1
baz <- firmly(f, chk_len(l = len))
\dontrun{
baz(1, 2:3)}

## Since the error message encodes the expression of `l` (i.e., `.expr$l`),
## unquote if you want to show the value of `l` instead
baz <- firmly(f, chk_len(l = !! len))
\dontrun{
baz(1, 2:3)}

## Predicate arguments can be (pre-)transformed
chk_with <- checker(.(., f ~ f(.)), f = rlang::as_function)
foobar <- firmly(f, "{{.}} is not positive" := chk_with(~ . > 0))
foobar(1, 2)
\dontrun{
foobar(1, 0)}

}
\seealso{
\link[=checker-boolean]{Boolean checkers},
\link[=checker-object]{Object checkers},
\link[=checker-pattern]{Pattern checkers},
\link[=checker-property]{Property checkers},
\link[=checker-relation]{Relation checkers},
\link[=checker-scalar-type]{Scalar type checkers},
\link[=checker-sets]{Set comparison checkers},
\link[=checker-type]{Type checkers}
}
